#!/usr/bin/env python3
"""Container entry point for the Victoria Terminal experience."""

from __future__ import annotations

import argparse
import os
import shutil
import sys
from pathlib import Path
from typing import Callable, Dict, Iterable, List

from rich.prompt import Confirm, Prompt

from common import (
    APP_HOME,
    banner,
    console,
    err,
    good,
    handle_error,
    info,
    initialize_colorama,
    load_dotenv,
    section,
    warn,
)
from VictoriaTerminal import SNOWFLAKE_ENV_VARS, ensure_default_files, main as terminal_main

ENV_FILENAME = ".env"
SHARED_CONFIG_ITEMS: tuple[str, ...] = (".env", "crush.json", "crush.overrides.json", "prompts")
SNOWFLAKE_PROMPTS: dict[str, str] = {
    "SNOWFLAKE_ACCOUNT": "Snowflake account identifier",
    "SNOWFLAKE_USER": "Snowflake username",
    "SNOWFLAKE_PASSWORD": "Snowflake password",
    "SNOWFLAKE_WAREHOUSE": "Snowflake warehouse",
    "SNOWFLAKE_ROLE": "Snowflake role",
}


def parse_env_file(path: Path) -> Dict[str, str]:
    """Parse a .env-style file into a dictionary."""

    if not path.exists():
        return {}
    values: Dict[str, str] = {}
    for raw_line in path.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        key, value = line.split("=", 1)
        key = key.strip()
        value = value.strip().strip('"').strip("'")
        if key:
            values[key] = value
    return values


def _serialize_env_value(key: str, value: str) -> str:
    if not value:
        return f"{key}="
    escaped = value.replace("\\", "\\\\").replace('"', '\\"')
    return f'{key}="{escaped}"'


def write_env_file(
    path: Path,
    values: Dict[str, str],
    order: Iterable[str] | None = None,
) -> None:
    """Write environment values to ``path`` in a stable order."""

    order_list: List[str] = list(order or (["OPENROUTER_API_KEY", *SNOWFLAKE_ENV_VARS]))
    seen = set()
    lines = [
        "# Victoria environment configuration",
        "# Generated by victoria_entrypoint.py",
    ]
    for key in order_list:
        lines.append(_serialize_env_value(key, values.get(key, "")))
        seen.add(key)
    for key in sorted(k for k in values if k not in seen):
        lines.append(_serialize_env_value(key, values.get(key, "")))
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def prompt_for_configuration(
    existing: Dict[str, str],
    *,
    _Confirm_ask: Callable[..., bool] = Confirm.ask,
    _Prompt_ask: Callable[..., str] = Prompt.ask,
    _section: Callable[[str], None] = section,
    _info: Callable[[str], None] = info,
    _warn: Callable[[str], None] = warn,
) -> Dict[str, str]:
    """Interactively collect configuration values from the user."""

    _section("Victoria configuration")
    _info(f"Configuration directory: {APP_HOME}")
    result = dict(existing)

    configure_openrouter = _Confirm_ask(
        "Configure OpenRouter API access?",
        default=bool(existing.get("OPENROUTER_API_KEY")),
    )
    if configure_openrouter:
        while True:
            key_default = existing.get("OPENROUTER_API_KEY", "")
            value = _Prompt_ask(
                "OpenRouter API key",
                default=key_default or None,
                show_default=bool(key_default),
            ).strip()
            if value:
                result["OPENROUTER_API_KEY"] = value
                break
            _warn("OpenRouter API key cannot be empty when OpenRouter support is enabled.")
    else:
        result.pop("OPENROUTER_API_KEY", None)

    configure_snowflake = _Confirm_ask(
        "Configure Snowflake credentials?",
        default=all(existing.get(var) for var in SNOWFLAKE_ENV_VARS),
    )
    if configure_snowflake:
        for env_var in SNOWFLAKE_ENV_VARS:
            default = existing.get(env_var, "")
            prompt_label = SNOWFLAKE_PROMPTS.get(env_var, env_var)
            value = _Prompt_ask(
                prompt_label,
                default=default or None,
                show_default=bool(default),
            ).strip()
            result[env_var] = value
    else:
        for env_var in SNOWFLAKE_ENV_VARS:
            result.pop(env_var, None)

    return result


def sync_shared_configuration(
    shared_home: Path,
    *,
    local_home: Path = APP_HOME,
    overwrite: bool = False,
    items: Iterable[str] = SHARED_CONFIG_ITEMS,
    _copy2: Callable[[Path, Path], Path] = shutil.copy2,
    _copytree: Callable[..., Path] = shutil.copytree,
    _rmtree: Callable[[Path], None] = shutil.rmtree,
    _info: Callable[[str], None] = info,
) -> List[Path]:
    """Copy configuration items from ``shared_home`` into ``local_home``."""

    copied: List[Path] = []
    try:
        if shared_home.resolve() == local_home.resolve():
            return copied
    except FileNotFoundError:
        pass
    if not shared_home.exists():
        return copied

    local_home.mkdir(parents=True, exist_ok=True)

    for name in items:
        src = shared_home / name
        if not src.exists():
            continue
        dest = local_home / name
        if src.is_dir():
            if dest.exists():
                if not overwrite:
                    continue
                _rmtree(dest)
            _copytree(src, dest)
            copied.append(dest)
        else:
            if dest.exists() and not overwrite:
                continue
            dest.parent.mkdir(parents=True, exist_ok=True)
            _copy2(src, dest)
            copied.append(dest)

    if copied:
        _info(
            "Synchronized shared configuration: "
            + ", ".join(path.name for path in copied)
        )
    return copied


def ensure_configuration(
    *,
    force_reconfigure: bool = False,
    interactive: bool = True,
    shared_home: Path | None = None,
    _APP_HOME: Path = APP_HOME,
    _parse_env_file: Callable[[Path], Dict[str, str]] = parse_env_file,
    _write_env_file: Callable[[Path, Dict[str, str]], None] = write_env_file,
    _prompt_for_configuration: Callable[[Dict[str, str]], Dict[str, str]] = prompt_for_configuration,
    _load_dotenv: Callable[[], None] = load_dotenv,
    _good: Callable[[str], None] = good,
    _info: Callable[[str], None] = info,
    _warn: Callable[[str], None] = warn,
) -> bool:
    """Ensure configuration exists and optionally interactively create it."""

    env_path = _APP_HOME / ENV_FILENAME

    if shared_home is not None:
        sync_shared_configuration(shared_home, local_home=_APP_HOME, overwrite=force_reconfigure)

    existing_values = _parse_env_file(env_path)

    if env_path.exists() and not force_reconfigure:
        _info(f"Using configuration from {env_path}")
        _load_dotenv()
        return True

    if force_reconfigure and env_path.exists():
        env_path.unlink()

    if not interactive:
        _warn("Configuration file not found and interactive mode disabled.")
        return False

    values = _prompt_for_configuration(existing_values)
    _write_env_file(env_path, values)
    _good(f"Configuration written to {env_path}")
    _load_dotenv()
    return True


def main(argv: list[str] | None = None) -> None:
    initialize_colorama()
    parser = argparse.ArgumentParser(
        description=(
            "Victoria container entry point. Ensures configuration exists and launches the terminal."
        )
    )
    parser.add_argument(
        "--shared-home",
        type=Path,
        default=os.environ.get("VICTORIA_SHARED_HOME"),
        help="Optional directory containing shared Victoria configuration to sync before launch.",
    )
    parser.add_argument(
        "--reconfigure",
        action="store_true",
        help="Force interactive configuration even if an existing .env file is present.",
    )
    parser.add_argument(
        "--non-interactive",
        action="store_true",
        help="Fail instead of prompting when configuration is missing.",
    )
    parser.add_argument(
        "--skip-launch",
        action="store_true",
        help="Only ensure configuration exists; do not start Victoria Terminal.",
    )
    args, remaining = parser.parse_known_args(argv)

    banner()

    shared_home = args.shared_home
    shared_path = Path(shared_home).expanduser() if shared_home else None

    configured = ensure_configuration(
        force_reconfigure=args.reconfigure,
        interactive=not args.non_interactive,
        shared_home=shared_path,
    )
    if not configured:
        err(
            "Victoria is not configured. Provide a shared ~/Victoria directory or rerun with interactive prompts."
        )
        sys.exit(1)

    ensure_default_files()

    if args.skip_launch:
        return

    original_argv = sys.argv[:]
    try:
        sys.argv = ["victoria-terminal", *remaining]
        terminal_main()
    finally:
        sys.argv = original_argv


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        console.print("\n[yellow]Victoria launch cancelled.")
        sys.exit(130)
    except Exception as exc:  # pragma: no cover - top-level safety
        handle_error(exc)
